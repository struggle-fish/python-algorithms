'''
栈：先进的后出去，砌墙的砖头，后来者居上
栈和队列的应用-迷宫问题

给一个二维列表，表示迷宫（0表示通道，1表示围墙）。给出算法，求一条走出迷宫的路径

maze = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
]

栈-深度优先搜索（一条路走到黑，不行了就往回走）
    回溯法
思路：从一个节点开始，任意找下一个能走的节点，当找不到能走的点时，退回上一个点寻找是否有其他方向的点。

使用栈存储当前路径

'''

'''
 上 - 右 - 下 -左
'''

maze = [
   # 0  1  2  3  4  5  6  7  8  9
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], # 0
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], # 1
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], # 2
    [1, 0, 0, 0, 0, 1, 1, 0, 0, 1], # 3
    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1], # 4
    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], # 5
    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], # 6
    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1], # 7
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], # 8
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], # 9
]
# lambda 表示匿名函数
dirs = [
    lambda x, y: (x + 1, y), # 点的下面
    lambda x, y: (x - 1, y), # 点的上面
    lambda x, y: (x, y - 1), # 点的左面
    lambda x, y: (x, y + 1)  # 点的右面
]

def maze_path(x1, y1, x2, y2):
    '''
    :param x1: 起点X坐标
    :param y1: 起点Y坐标
    :param x2: 终点X坐标
    :param y2: 终点Y坐标
    :return:
    '''
    stack = [] # 空栈 存放每一步走的坐标(x, y)
    stack.append((x1, y1))

    # 只要栈不空就循环
    # 栈空了，表示没有路
    while(len(stack) > 0):
        curNode = stack[-1] # 当前走到哪个节点了 => 列表中的最后一个节点
        if curNode[0] == x2 and curNode[1] == y2:
            # 走到终点了
            for p in stack:
                print('路线', p)
            return True
        # 上下左右 四个方向
        # 上 x - 1  下：x + 1 左 y -1 右 y + 1
        for dir in dirs:
            nextNode = dir(curNode[0], curNode[1])
            row, col = nextNode # row = nextNode[0]  col = nextNode[1]
            # 如果下一个节点能走
            if maze[row][col] == 0:
                stack.append(nextNode)
                maze[row][col] = 2 # 表示2 已经走过了
                break
        else:
            # 一个都找不到，往回退
            maze[row][col] = 2
            stack.pop() # 弹出最后一个
    else:
        print('没有路了') # 退回到了原点
        return False


maze_path(1, 1, 8, 8)



























